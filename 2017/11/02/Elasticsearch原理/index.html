<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Blog"><title>Elasticsearch原理 | Jack Wang Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Elasticsearch原理</h1><a id="logo" href="/.">Jack Wang Blog</a><p class="description">Goals determine what you are going to be</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa icon-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Elasticsearch原理</h1><div class="post-meta">Nov 2, 2017<span> | </span><span class="category"><a href="/categories/ELK/">ELK</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-disqus-identifier="2017/11/02/Elasticsearch原理/" href="/2017/11/02/Elasticsearch原理/#disqus_thread" class="disqus-comment-count"></a><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#动态更新的Lucene索引"><span class="toc-number">1.</span> <span class="toc-text">动态更新的Lucene索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#利用磁盘缓存实现的准实时检索"><span class="toc-number">2.</span> <span class="toc-text">利用磁盘缓存实现的准实时检索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#translog-提供的磁盘同步控制"><span class="toc-number">3.</span> <span class="toc-text">translog 提供的磁盘同步控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#segment-merge的影响"><span class="toc-number">4.</span> <span class="toc-text">segment merge的影响</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#routing-和-replica的读写过程"><span class="toc-number">5.</span> <span class="toc-text">routing 和 replica的读写过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shard-的-allocate-控制"><span class="toc-number">6.</span> <span class="toc-text">shard 的 allocate 控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reroute-接口"><span class="toc-number">7.</span> <span class="toc-text">reroute 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#节点下线（迁移）"><span class="toc-number">8.</span> <span class="toc-text">节点下线（迁移）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#冷热数据的读写分离"><span class="toc-number">9.</span> <span class="toc-text">冷热数据的读写分离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Elasticsearch自动发现的配置"><span class="toc-number">10.</span> <span class="toc-text">Elasticsearch自动发现的配置</span></a></li></ol></div></div><div class="post-content"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><p>Elasticsearch原理<br><a id="more"></a></p>
<h3 id="动态更新的Lucene索引"><a href="#动态更新的Lucene索引" class="headerlink" title="动态更新的Lucene索引"></a>动态更新的Lucene索引</h3><p>Lucene处理方法，新收到的数据写到新文件里<br>Lucene把每次生成的倒排索引，叫做一个段（segment）。使用一个commit文件记录索引内所有的段，生产的segment的数据来源则是放在内存的buffer  </p>
<ol>
<li>当前索引有3个segment可用</li>
<li>新接收的数据进入内存buffer</li>
<li>内存buffer刷到磁盘，生成一个新的segment，commit文件同步更新<br><img src="http://note.youdao.com/yws/api/personal/file/E0FB3DE0ED34483699E2FD08AF8B07AA?method=download&amp;shareKey=4e8edcbd0741fefc8a26222648236865" alt="动态更新的Lucene索引">  </li>
</ol>
<h3 id="利用磁盘缓存实现的准实时检索"><a href="#利用磁盘缓存实现的准实时检索" class="headerlink" title="利用磁盘缓存实现的准实时检索"></a>利用磁盘缓存实现的准实时检索</h3><p>相对来说，磁盘处理速度很慢，因此在上述第三步中还存在一个中间状态  </p>
<ol>
<li>内存buffer生成一个新的segment，刷新到文件系统缓存中，Lucene即可检索这个新的segment</li>
<li>文件系统缓存真正同步到磁盘，commit文件更新<br>这一步刷新到文件系统缓存的步骤，在Elasticsearch中默认是1秒间隔，对于大部分应用来说，几乎是实时可搜索了。Elasticsearch也提供了单独的<code>/_refresh</code>接口，用户如果不满意，可以主动调整<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#加大refresh_interval参数</span></div><div class="line"><span class="comment"># curl -XPOST http://localhost:9200/192.168.1.24-weixin_log-2017.10.28/_settings -d '</span></div><div class="line">&#123; <span class="string">"refresh_interval"</span>: <span class="string">"10s"</span> &#125;</div><div class="line"><span class="string">'</span></div></pre></td></tr></table></figure>
</li>
</ol>
<p>如果导入的是历史数据，可以关闭<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># curl -XPOST http://localhost:9200/192.168.1.24-weixin_log-2017.10.28 -d '</span></div><div class="line">&#123;</div><div class="line">    <span class="string">"settings"</span>: &#123;</div><div class="line">        <span class="string">"refresh_interval"</span>: <span class="string">"-1"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="string">'</span></div></pre></td></tr></table></figure></p>
<p>在导入完成后，修改回原来的值或者手动调用一次<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># curl -XPOST http://localhost:9200/192.168.1.24-weixin_log-2017.10.27/_refresh?pretty=true</span></div><div class="line">&#123;</div><div class="line">  <span class="string">"_shards"</span> : &#123;</div><div class="line">    <span class="string">"total"</span> : 10,</div><div class="line">    <span class="string">"successful"</span> : 10,</div><div class="line">    <span class="string">"failed"</span> : 0</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://note.youdao.com/yws/api/personal/file/FD45A9D1BDDF4D92BFFBA09E04872591?method=download&amp;shareKey=735c6c6ebf035d8836ec5d827aa7e7fc" alt="利用磁盘缓存实现的准实时检索">  </p>
<h3 id="translog-提供的磁盘同步控制"><a href="#translog-提供的磁盘同步控制" class="headerlink" title="translog 提供的磁盘同步控制"></a>translog 提供的磁盘同步控制</h3><p>Elasticsearch在把数据写入到内存buffer时，还记录了一个translog的日志，来保证期间发生主机错误、硬件故障等异常情况时数据不会丢失<br>如果在这期间发生异常，Elasticsearch会从 commit 位置开始恢复整个translog文件中的记录<br><img src="http://note.youdao.com/yws/api/personal/file/6F91BABFB8B44FA2878D7FC4DF36EA8C?method=download&amp;shareKey=b5b3bb7b92596d736f0e8eb4b0b99079" alt="translog提供的磁盘同步控制"><br>等到真正把segment刷到磁盘，且commit 文件进行更新的时候，translog文件才清空，这一步叫flush。Elasticsearch也提供了<code>/_flush</code>接口<br>Elasticsearch默认设置为每30分钟主动执行一次flush，或者当translog文件大于512M时，两者分别可以通过<code>index.translog.flush_threshold_period</code>和<code>index.translog.flush_threshold_size</code>参数控制，Elasticsearch还可以通过<code>index.translog.flush_threshold_ops</code>参数设置每收到多少条数据后flush一次  </p>
<p>默认情况下，Elasticsearch每5秒，或每次请求操作结束前，会强制刷新 translog日志到磁盘。为了保证不丢数据 ，每次index、bulk、delete、update完成时，一定会触发新translog到磁盘，才给请求返回200 OK。这个改变提供数据安全性的同时降低了一点性能<br>可以在index template里设置如下参数来控制<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="string">"index.translog.durability"</span>: <span class="string">"async"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="segment-merge的影响"><a href="#segment-merge的影响" class="headerlink" title="segment merge的影响"></a>segment merge的影响</h3><p>从前面看Lucene会写很多“新文件”，但这样会给服务器带来很大的负荷，每个文件都需要文件句柄，内存，CPU等各种资源，磁盘inode也有限<br>Elasticsearch通过segment merge操作将很多零散的segment做数据归并。这个过程有独立的线程来操作，并不影响新的segment的产生<br>当归并完成后，较大的segment刷到磁盘，commit文件做出相应变更，删除前面小的segment<br><img src="http://note.youdao.com/yws/api/personal/file/288CB47874D84FE5B4924D1DF06CA3A0?method=download&amp;shareKey=5cef29dfcfb7b1ed2d76c44fbe5da40d" alt="segment merge">  </p>
<p>并归线程配置<br>segment归并过程中，需要读取segment，归并计算，再写新的segment，最后还要保存到磁盘。此过程非常消耗磁盘I/O和CPU的任务。所以，Elasticsearch提供了对归并线程的限速机制，要确保这个任务不会影响到其他的任务<br>归并线程的限速配置<code>indices.store.throttle.max_bytes_per_sec</code>在Elasticsearch 5.0默认是10240MB，使用了Lucene CMS（ConcurrentMergeScheduler）的auto throttle机制，正常情况下不需要手动配置。配置参数如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># curl -XPUT http://localhost:9200/_cluster/settings -d '</span></div><div class="line">&#123;</div><div class="line">        <span class="string">"persistent"</span>: &#123;</div><div class="line">            <span class="string">"indices.store.throttle.max_bytes_per_sec"</span>: <span class="string">"100mb"</span></div><div class="line">        &#125;</div><div class="line">&#125;<span class="string">'</span></div></pre></td></tr></table></figure></p>
<p>归并线程数目，Elasticsearch也通过计算公式控制：Math.min(3,Runtime.getRuntime().availableProcessors()/2)。即服务器CPU核数的一半大于3时，启用3个归并线程，否则启动跟CPU核数的一半相等的线程数。如果确定磁盘I/O不够，可以降低<code>index.merge.schedule.max_thread_count</code>配置修改  </p>
<p>归并策略主要有以下几条：  </p>
<ul>
<li><code>index.merge.policy.floor_segment</code> 默认2MB，小于这个值得segment优先被归并</li>
<li><code>index.merge.policy.max_merge_at_once</code> 默认一次归并10个segment</li>
<li><code>index.merge.policy.max_merge_at_once_explicit</code> 默认forcemerge时一次最多归并30个segment</li>
<li><code>index.merge.policy.max_merged_segment</code> 默认是5G，大于这个值得segment，不用参与归并，optimize除外</li>
</ul>
<p>forcemerge接口<br>segment最大为5G，也会存在很多的segment，但因归并任务太消耗资源，所以一般不选择加大<code>index.merge.policy.max_merged_segment</code>配置，而在较低负荷时间段，通过forcemerge接口，强行归并segment<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># curl -XPOST http://localhost:9200/192.168.1.24-weixin_log-2017.10.28/_forcemerge?max_num_segments=1</span></div><div class="line">&#123;<span class="string">"_shards"</span>:&#123;<span class="string">"total"</span>:10,<span class="string">"successful"</span>:10,<span class="string">"failed"</span>:0&#125;&#125;</div></pre></td></tr></table></figure></p>
<p>forcemerge线程消耗服务器资源比普通的归并线程还大，所以不要在写入数据的热索引执行这个操作，一般索引都是按天分割的  </p>
<h3 id="routing-和-replica的读写过程"><a href="#routing-和-replica的读写过程" class="headerlink" title="routing 和 replica的读写过程"></a>routing 和 replica的读写过程</h3><p>在Elasticsearch分布层面上，当一个Elasticsearch节点收到一条数据的请求时，通过以下方式来确认数据应该存储到哪个分片的  </p>
<ol>
<li>路由计算<br>Elasticsearch没有额外的依赖，对任意一条数据计算其对应分片的方式如下  <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">shard = <span class="built_in">hash</span>(routing) % number_of_primary_shards</div></pre></td></tr></table></figure>
</li>
</ol>
<p>每个数据都有一个routing参数，默认情况下，使用其<code>_id</code>值。将其<code>_id</code>值哈希计算后，对索引的主分片数取余，就是数据实际应该存储到的分片ID。<br>由于取余这种计算方式，完全依赖分母，所以不能修改索引的主分片数。一旦主分片数不一样，所有数据的存储位置计算结果都会改变，索引数据将完全不可读。  </p>
<p>副本一致性<br>数据副本是分布式系统的一个标配。数据流程如下：<br><img src="http://note.youdao.com/yws/api/personal/file/BA7FE1FF0D25420BB14CA1D7EEC67193?method=download&amp;shareKey=ac023a5a0bed3c9485219979e64ef9e3" alt="数据写入流程">  </p>
<ol>
<li>客户端请求发送给node1节点，图中node1为master节点</li>
<li>node1用数据的<code>id_</code>取余计算得到应该将数据存储到share0上，通过cluster state信息发现share0的主分片已经分配到node3上，node1将请求数据给node3  </li>
<li>node3完成请求数据的索引过程，存入主分片0，然后并行转发数据给分配由shard0的副本分片的node1和node2。当收到任一节点汇报副本分片数据写入成功，node3即返回给初始的接收节点node1，宣布数据写入成功。node1返回成功响应给客户端<br>下面几个参数可以控制这个过程：  </li>
</ol>
<ul>
<li><code>wait_for_active_shards</code>: 两个副本只要有一个成功，就返回给客户端，默认值计算如下<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int((primary + number_of_replicas)/2 ) +1</div></pre></td></tr></table></figure>
</li>
</ul>
<p>该参数通过<code>index.write.wait_for_active_shards</code>在索引级别设置，也可以根据需要单个写入请求上作为参数使用，设置成为1仅写完主分片就返回；设置为all，表示等所有副本分片都写入完成才返回，还可以设置为介于1和<code>number_of_replicas +1</code>之间的值  </p>
<ul>
<li><code>timeout</code>: 如果集群出现异常，有些分片不可用，Elasticsearch会等待1分钟确认分片是否正常，可以用<code>?timeout=30s</code>参数来缩短这个等待的时间<br>副本配置和分片配置不一样，可以随时调整。有些较大的索引，甚至可以在做<code>optimize</code>前，先把副本全部取消，等<code>optimize</code>完成后，在重新开启副本，节约单个segment的重复归并消耗  <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># curl -XPUT http://localhost:9200/192.168.1.24-weixin_log-2017.10.28/_settings -d '</span></div><div class="line">&#123;</div><div class="line">    <span class="string">"index"</span>: &#123; <span class="string">"number_of_replicas"</span>: 0 &#125;</div><div class="line">&#125;</div><div class="line"><span class="string">'</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="shard-的-allocate-控制"><a href="#shard-的-allocate-控制" class="headerlink" title="shard 的 allocate 控制"></a>shard 的 allocate 控制</h3><p>Elasticsearch由以下策略来决定某个shard分配在哪个节点，是由Elasticsearch自行决定的  </p>
<ul>
<li>新索引的生成</li>
<li>索引的删除</li>
<li>新增副本分片</li>
<li>节点增减引发的数据平衡</li>
</ul>
<p>Elasticsearch控制这部分逻辑的参数如下：  </p>
<ul>
<li><code>cluster.routing.allocation.enable</code> 参数用来控制允许分配哪种分片。默认是all。可选项包含<code>primaries</code> 和<code>new_primaries</code>。<code>none</code>则彻底拒绝分片</li>
<li><code>cluster.routing.allocation.allow_rebalance</code> 参数用来控制什么时候允许数据平衡。默认是<code>indices_all_active</code>，即要求所有分片都正常启用以后，才可以进行数据平衡操作，否则在集群重启阶段，会浪费很多流量</li>
<li><code>cluster.routing.allocation.cluster_concurrent_rebalance</code> 参数用来控制集群内同时运行的数据均衡任务个数。默认是2个，如果有节点增减，且集群负载压力不高的情况下，可以适当加大</li>
<li><code>cluster.routing.allocation.node_initial_primaries_recoveries</code> 参数用来控制节点重启时，允许同时恢复几个主分片。默认是4个，如果节点是多磁盘，且I/O压力不大，可以适当增加</li>
<li><code>cluster.routing.allocation.node_concurrent_recoveries</code> 参数用来控制节点除了主分片重启恢复以外其他情况下，允许同时运行的数据恢复任务。默认是2个。所以，节点重启时，可以看到主分片通过本地恢复迅速完成，副分片通过网络复制的恢复却很慢，并发线程本身也减少了一半。在Elasticsearch 1.6后，冷索引的副本分片也可以本地恢复，可以适当加大</li>
<li><code>indices.recovery.concurrent_streams</code> 参数用来控制节点从网络复制恢复副本分片时的数据流个数。默认是3个，可以配合上一条配置一起加大  </li>
<li><code>indices.recovery.max_bytes_per_sec</code> 参数用来控制节点恢复时的速率。默认是 40MB</li>
</ul>
<p>运维人员较常见的策略有2种：  </p>
<ul>
<li><p>磁盘限额，为了保护节点数据安全。Elasticsearch会定时（<code>cluster.info.update.interval</code>默认为30秒）检查一下各节点的数据目录磁盘使用情况。在达到<code>cluster.routing.allocation.disk.watermark.low</code>（默认85%）的时候，新索引分片就不会再分配到这个节点上了。在达到<code>cluster.routing.allocation.disk.watermark.high</code>（默认90%）的时候就会触发该节点现存分片的数据平衡，把数据挪到其他节点上去。这两个值可以写成百分比或者具体字节数。可以适当修改参数配置：  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># curl -XPUT http://localhost:9200/_cluster/settings -d '&#123;</span></div><div class="line"><span class="string">"transient"</span>: &#123;</div><div class="line">    <span class="string">"cluster.routing.allocation.disk.watermark.low"</span>: <span class="string">"85%"</span>,</div><div class="line">    <span class="string">"cluster.routing.allocation.disk.watermark.high"</span>: <span class="string">"10gb"</span>,</div><div class="line">    <span class="string">"cluster.info.update.interval"</span>: <span class="string">"1m"</span></div><div class="line">&#125;</div><div class="line">&#125;<span class="string">'</span></div></pre></td></tr></table></figure>
</li>
<li><p>热索引分片不均。默认情况下，Elasticsearch集群的数据均衡策略是以各节点的分片总数（<code>indices_all_active</code>）作为基准的。可以提高均衡搜索压力。一般压力集群中在新索引的数据写入方面，正常运行时，没有问题的。但当集群扩容时，新加入集群的节点，分片总数远低于其他节点，如果有新的索引创建，Elasticsearch的默认策略会导致新索引的所有主分片几乎全部分配到这个新节点上。整个集群的写入压力全部在这个节点上，可以会导致这个节点出现异常，集群出现异常。<br>在ELK环境中，需要预先计算好索引的分片数，配置好单节点的分片限额。比如：一个5节点的集群，索引主分片10个，副本1个，则平均下来每个节点应该有4个分片，则应配置为：  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># curl -XPUT http://localhost:9200/192.168.1.24-weixin_log-2017.10.28/_settings -d '&#123;</span></div><div class="line">    <span class="string">"index"</span>: &#123; <span class="string">"routing.allocation.total_shards_per_node"</span>: <span class="string">"5"</span> &#125;</div><div class="line">&#125;<span class="string">'</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>这里配置的是5而不是4，需要预防有机器故障，分片发生迁移失败的情况  </p>
<p>Elasticsearch中有一系列参数互相影响，最终联合决定分片分配：  </p>
<ul>
<li><code>cluster.routing.allocation.balance.shard</code> 节点上分配分片的权重，默认值为 0.45。 数值越大越倾向于在节点层面均衡分片  </li>
<li><code>cluster.routing.allocation.balance.index</code> 每个索引往单个节点上分配分片的权重，默认值为0.55。 数值越大越倾向于在索引层面均衡分片</li>
<li><code>cluster.routing.allocation.balance.threshold</code> 大于阈值则触发均衡操作。默认值为1。 Elasticsearch计算方法是：<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(indexBalance (node.numShards(index) - avgShardsPerNode(index)) + shardBalance (node.numShards() - avgShardsPerNode)) &lt;=&gt; weightthreshold</div></pre></td></tr></table></figure>
</li>
</ul>
<p>所以，也可以采取加大<code>cluster.routing.allocation.balance.index</code>的措施，甚至设置<code>cluster.routing.allocation.balance.shard</code> 为0来尽量采用索引内的节点均衡  </p>
<h3 id="reroute-接口"><a href="#reroute-接口" class="headerlink" title="reroute 接口"></a>reroute 接口</h3><p>上述都是从策略层面控制分片的选择，在必要的时候可以通过Elasticsearch的<code>reroute</code>接口，手动完成对分片的分配选择的控制<br>reroute接口支持三种指令：<code>allocate</code>、<code>move</code>、<code>cancel</code>，常用的是<code>allocate</code>和<code>move</code>  </p>
<ul>
<li><code>allocate</code>指令：因为负载过高等原因，有时候个别分片长期处于<code>UNASSIGNED</code>状态，可以手动分配分片到指定节点上。默认情况下只允许手动分配副本分片，所以如果是主分片故障，需要单独加一个<code>allow_primary</code>选项  <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># curl -XPOST http://localhost:9200/_cluster/reroute -d '&#123;</span></div><div class="line"><span class="string">"commands"</span>: [&#123;</div><div class="line">    <span class="string">"allocate"</span>: &#123;</div><div class="line">        <span class="string">"index"</span>: <span class="string">"192.168.1.24-weixin_log-2017.10.28"</span>, <span class="string">"shard"</span>: 61, <span class="string">"node"</span>: <span class="string">"192.168.1.42"</span>, <span class="string">"allow_primary"</span>: <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">    &#125;]</div><div class="line">&#125;<span class="string">'</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>注：如果是历史数据的话，需要提前确认哪个节点上保留有这个分片的实际目录，且目录大小最大。然后手动分片到这个节点上，以此减少数据丢失。  </p>
<ul>
<li><code>move</code>指令： 因负载过高，磁盘利用率过高，服务器下线，更换磁盘等原因，可能会需要从节点上移走部分分片<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># curl -XPOST http://localhost:9200/_cluster/reroute -d '&#123;</span></div><div class="line"><span class="string">"command"</span>: [&#123;</div><div class="line">    <span class="string">"move"</span>: &#123;</div><div class="line">        <span class="string">"index"</span>: <span class="string">"192.168.1.24-weixin_log-2017.10.28"</span>, <span class="string">"shard"</span>: 0, <span class="string">"from_node"</span>: <span class="string">"192.168.1.43"</span>, <span class="string">"to_node"</span>: <span class="string">"192.168.1.42"</span></div><div class="line">    &#125;</div><div class="line">    &#125;]</div><div class="line">&#125;<span class="string">'</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>如果自己手动reroute失败，Elasticsearch返回的响应中会带上失败的原因。从Elasticsearch 5.0开始，新增了一个<code>allocation explain</code>接口，用来解释指定分片的具体失败原因<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># curl -XGET 'http://localhost:9200/_cluster/allocation/explain' -d '&#123;</span></div><div class="line"><span class="string">"index"</span>: <span class="string">"192.168.1.24-weixin_log-2017.10.28"</span>,</div><div class="line"><span class="string">"shard"</span>: 0,</div><div class="line"><span class="string">"primary"</span>: <span class="literal">false</span></div><div class="line">&#125;<span class="string">'</span></div></pre></td></tr></table></figure></p>
<p>得到的响应如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="string">"shard"</span>: &#123;</div><div class="line">        <span class="string">"index"</span>: <span class="string">"192.168.1.24-weixin_log-2017.10.28"</span>,</div><div class="line">        <span class="string">"index_uuid"</span>: <span class="string">"KnW0-zELRs6PK8410r38ZA"</span>,</div><div class="line">        <span class="string">"id"</span>: 0,</div><div class="line">        <span class="string">"primary"</span>: <span class="literal">false</span></div><div class="line">    &#125;,</div><div class="line">    <span class="string">"assigned"</span>: <span class="literal">false</span>,</div><div class="line">    <span class="string">"shard_state_fetch_pending"</span>: <span class="literal">false</span>,</div><div class="line">    <span class="string">"unassigned_info"</span>: &#123;</div><div class="line">        <span class="string">"reason"</span>: <span class="string">"INDEX_CREATED"</span>,</div><div class="line">        <span class="string">"at"</span>: <span class="string">"2017-10-28T20:04:23.620Z"</span></div><div class="line">    &#125;,</div><div class="line">    <span class="string">"allocation_delay_ms"</span>: 0,</div><div class="line">    <span class="string">"remaining_delay_ms"</span>: 0,</div><div class="line">    <span class="string">"nodes"</span>: &#123;</div><div class="line">        <span class="string">"V-Spi0AyRZ6ZvKbaI3691w"</span>: &#123;</div><div class="line">            <span class="string">"node_name"</span>: <span class="string">"H5dfFeA"</span>,</div><div class="line">            <span class="string">"node_attributes"</span>: &#123;</div><div class="line">                <span class="string">"bar"</span>: <span class="string">"baz"</span></div><div class="line">            &#125;,</div><div class="line">            <span class="string">"store"</span>: &#123;</div><div class="line">                <span class="string">"shard_copy"</span>: <span class="string">"NONE"</span></div><div class="line">            &#125;,</div><div class="line">            <span class="string">"final_decision"</span>: <span class="string">"NO"</span>,</div><div class="line">            <span class="string">"final_explanation"</span>: <span class="string">"the shard cannot be assigned because one or more allocation decider returns a 'NO' decision"</span>,</div><div class="line">            <span class="string">"weight"</span>: 0.06666675,</div><div class="line">            <span class="string">"decisions"</span>: [&#123;</div><div class="line">                <span class="string">"decider"</span>: <span class="string">"filter"</span>,</div><div class="line">                <span class="string">"decision"</span>: <span class="string">"NO"</span>,</div><div class="line">                <span class="string">"explanation"</span>: <span class="string">"node does not match index include filters [foo:\"bar\"]"</span></div><div class="line">                &#125;]</div><div class="line">            &#125;,</div><div class="line">            <span class="string">"Qc6VL8c5RWaw1qXZ0Rg57g"</span>: &#123;</div><div class="line">                ...</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>这是一段很长的JSON字符，会把集群里所有节点都列上来，挨个解释为什么不能分配到这个节点上  </p>
<h3 id="节点下线（迁移）"><a href="#节点下线（迁移）" class="headerlink" title="节点下线（迁移）"></a>节点下线（迁移）</h3><p>集群中个别节点出现故障预警，也是在Elasticsearch运维工作中常见的情况。如果已经稳定运行了一段时间的集群，每个节点上都保存有数量不少的分片，这时通过 reroute接口手动转移就太麻烦了，可以采取另一种方式：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># curl -XPUT http://localhost:9200/_cluster/settings -d '&#123;</span></div><div class="line"><span class="string">"transient"</span>: &#123;</div><div class="line">    <span class="string">"cluster.routing.allocation.exclude._ip"</span>: <span class="string">"192.168.1.43"</span></div><div class="line">&#125;</div><div class="line">&#125;<span class="string">'</span></div></pre></td></tr></table></figure></p>
<p>Elasticsearch就会把这个IP节点上的所有分片，都自动转移到其他的节点上。等转移完成后，这个节点就可以毫无影响的下线了<br>和<code>_ip</code>类似的参数还有<code>_host</code>，<code>_name</code>等。这类参数不仅仅是cluster级别，也可以是index级别  </p>
<h3 id="冷热数据的读写分离"><a href="#冷热数据的读写分离" class="headerlink" title="冷热数据的读写分离"></a>冷热数据的读写分离</h3><p>实施步骤如下：  </p>
<ol>
<li>N台机器做热数据的存储，上面只放当天的数据。这N台数据节点上面的elasticsearch.yml中配置<code>node.tag: host</code></li>
<li>之前的数据放在另外的M台机器上，这M台机器冷数据节点中配置<code>node.tag: stale</code></li>
<li><p>模版中控制对新建索引添加<code>hot</code>标签：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="string">"order"</span>: 0,</div><div class="line">    <span class="string">"template"</span>: <span class="string">"*"</span>,</div><div class="line">    <span class="string">"settings"</span>: &#123;</div><div class="line">        <span class="string">"index.routing.allocation.require.tag"</span>: <span class="string">"hot"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>每天计划任务更新索引的配置，将<code>tag</code>更变为<code>stale</code>，索引会自动迁移到M台冷数据节点  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># curl -XPUT http://localhost:9200/indexname/_settings -d '</span></div><div class="line">&#123;</div><div class="line">    <span class="string">"index"</span>: &#123;</div><div class="line">        <span class="string">"routing"</span>: &#123;</div><div class="line">            <span class="string">"allocation"</span>: &#123;</div><div class="line">                <span class="string">"require"</span>: &#123;</div><div class="line">                    <span class="string">"tag"</span>: <span class="string">"stale"</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;<span class="string">'</span></div></pre></td></tr></table></figure>
</li>
</ol>
<p>这样，写操作就在N台热数据节点上，大范围的独操作集中在M台冷数据节点上，避免了堵塞影响<br>参考： <a href="https://www.elastic.co/guide/en/elasticsearch/reference/master/shard-allocation-filtering.html" target="_blank" rel="external">https://www.elastic.co/guide/en/elasticsearch/reference/master/shard-allocation-filtering.html</a>  </p>
<h3 id="Elasticsearch自动发现的配置"><a href="#Elasticsearch自动发现的配置" class="headerlink" title="Elasticsearch自动发现的配置"></a>Elasticsearch自动发现的配置</h3><p>Elasticsearch是P2P类型（gossip协议）的分布式系统，除了集群状态管理以外，其他所有的请求都可以发送到集群内任意一台节点上，这个节点可以自己找到需求转发给哪些节点，并且直接跟这个节点通讯。<br>在Elasticsearch 5.0以后自动发现方式为单播（unicast）方式，原来的组播（multicast）被彻底删除。<br>单播方式的配置里，提供几台节点的地址里（和可选端口），Elasticsearch将其视作 <code>gossip router</code>角色，借以完成集群的发现。由于这只是Elasticsearch内很小的一个功能，所以，<code>gossip router</code>角色并不需要单独配置，每个Elasticsearch节点都可以担任。所以采用单播方式的集群，各个节点都配置相同的几个节点列表作为<code>router</code>即可。<br>此外，考虑到节点有时候因为高负载，慢GC等原因，可能会有偶尔没有及时相应的<code>ping</code>包，一般建议稍微加大<code>Fault Detection</code>的超时时间。同样基于安全考虑做的变更，还有监听的主机名，现在默认只监听本地lo网卡上的信号。所以正式环境上需要修改配置为监听具体的网卡：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">network.host: <span class="string">"192.168.1.41"</span></div><div class="line">discovery.zen.minimum_master_nodes:3</div><div class="line">discovery.zen.ping.timeout: 100s</div><div class="line">discovery.zen.fd.ping_timeout: 100s</div><div class="line">discovery.zen.ping.multicast.enabled: <span class="literal">false</span></div><div class="line">discovery.zen.ping.unicase.hosts: [<span class="string">"192.168.1.41"</span>,<span class="string">"192.168.1.42"</span>,<span class="string">"192.168.1.43"</span>]</div></pre></td></tr></table></figure></p>
<p>上面的<code>fd</code>是<code>fault detection</code>的缩写  </p>
<ul>
<li><code>discovery.zen.ping.timeout</code> 参数仅在加入或者选举master主节点的时候才起作用</li>
<li><code>discovery.zen.fd.ping_timeout</code> 参数在稳定运行的集群中，master检测所有节点，以及节点检测master是否正常时，长期有用</li>
</ul>
<p>既然是长期使用，自然还有运行间隔和重试配置，可以根据实际情况调整：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">discovery.zen.fd.ping_intervel: 10s</div><div class="line">discovery.zen.fd.ping_retries: 10</div></pre></td></tr></table></figure></p>
<hr>
<p>本作品采用<a href="https://creativecommons.org/licenses/by/2.5/cn/" target="_blank" rel="external">知识共享署名 2.5 中国大陆许可协议</a>进行许可，欢迎转载，但转载请注明来自<a href="http://www.yfshare.vip">Jack Wang Blog</a>，并保持转载后文章内容的完整。本人保留所有版权相关权利。<br><img src="http://note.youdao.com/yws/api/personal/file/FE3C6F68961F4541AF284E5F346FC3CA?method=download&amp;shareKey=c5e4c3ca81daa6e908d5630f8c6ec242" alt="打赏"><br>本文出自”Jack Wang Blog”：<a href="http://www.yfshare.vip/2017/11/02/Elasticsearch原理/">http://www.yfshare.vip/2017/11/02/Elasticsearch原理/</a></p>
</div><script type="text/javascript" src="/js/share.js?v=2.0.0" async></script><a data-url="http://www.yfshare.vip/2017/11/02/Elasticsearch原理/" data-id="cjk427wgr0013fom5glyo40nq" class="article-share-link">分享到</a><div class="tags"><a href="/tags/Elasticsearch/">Elasticsearch</a></div><div class="post-nav"><a href="/2017/11/04/部署FileBeat-logstash-elasticsearch集群-kibana/" class="pre">部署FileBeat+logstash+elasticsearch集群+kibana</a><a href="/2017/10/30/Kibana5使用指南/" class="next">Kibana5使用指南</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论 「请确保 disqus.com 可以正常加载」</button></div><script>var disqus_shortname = 'yfshare';
var disqus_identifier = '2017/11/02/Elasticsearch原理/';
var disqus_title = 'Elasticsearch原理';
var disqus_url = 'http://www.yfshare.vip/2017/11/02/Elasticsearch原理/';
$('.btn_click_load').click(function() {
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
  $('.btn_click_load').css('display','none');
});
$.ajax({
  url: 'https://disqus.com/favicon.ico',
  timeout: 3000,
  type: 'GET',
  success: (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    $('.btn_click_load').css('display','none');
  })(),
  error: function() {
    $('.btn_click_load').css('display','block');
  }
});</script><script id="dsq-count-scr" src="//yfshare.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Ansible/">Ansible</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Atlassian/">Atlassian</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Database/">Database</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/">Docker</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ELK/">ELK</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Jenkins/">Jenkins</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/K8S/">K8S</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Security/">Security</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Virtualization/">Virtualization</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/WEB/">WEB</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Windows/">Windows</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Zabbix/">Zabbix</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/版本控制系统/">版本控制系统</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/运维知识体系/">运维知识体系</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/07/27/操作系统层/">操作系统层</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/04/部署jenkins项目/">部署jenkins项目</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/30/部署Zabbix-3-4/">部署Zabbix 3.4</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/21/Ansible部署Jenkins环境/">Ansible部署Jenkins环境</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/28/k8s滚动升级-RollingUpdate/">k8s滚动升级(RollingUpdate)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/21/Ansible部署TLS-K8S/">Ansible部署TLS K8S</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/17/glusterfs做持久化存储/">glusterfs做持久化存储</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/14/Prometheus监控TLS-Kubernetes集群/">Prometheus监控TLS Kubernetes集群</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/23/部署TLS-k8s/">部署TLS k8s</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/11/自建docker私有仓库-Vmware-Harbor/">自建docker私有仓库(Vmware Harbor)</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://yfshare.blog.51cto.com/" title="酱油瓶 博客" target="_blank">酱油瓶 博客</a><ul></ul><a href="http://zerosre.com/" title="龙哥zero 博客" target="_blank">龙哥zero 博客</a><ul></ul><a href="http://renzhiyuan.blog.51cto.com/" title="任志远Ray 博客" target="_blank">任志远Ray 博客</a><ul></ul><a href="http://rongrong.njdgwl.com" title="浩子的 博客" target="_blank">浩子的 博客</a><ul></ul><a href="http://www.cnblogs.com/aresxin/" title="欣哥aresxin 博客" target="_blank">欣哥aresxin 博客</a><ul></ul><a href="http://securityit.cn/" title="万马奔腾" target="_blank">万马奔腾</a></div><div class="widget"><div class="widget-title"><i class="fa fa-external-resources"> 资源站</i></div><ul></ul><a href="http://mirror.symnds.com/distributions/CentOS-vault/" title="Centos镜像站" target="_blank">Centos镜像站</a><ul></ul><a href="http://www.rpmfind.net/" title="rpmfind mirror" target="_blank">rpmfind mirror</a><ul></ul><a href="http://rpm.org/" title="rpm.org" target="_blank">rpm.org</a><ul></ul><a href="http://rpm.pbone.net/" title="rpm search" target="_blank">rpm search</a><ul></ul><a href="http://download.chinaunix.net/" title="chinaunix download" target="_blank">chinaunix download</a><ul></ul><a href="http://www.anquanquan.info/" title="安全圈info" target="_blank">安全圈info</a><ul></ul><a href="http://source.tosimp.net/" title="Tosimp 资源站" target="_blank">Tosimp 资源站</a></div><div class="widget"><div class="widget-title"><i class="fa fa-external-music"> 音乐</i></div></div><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=371362&auto=1&height=66"></iframe><div class="widget"><div class="widget-title"><i class="fa fa-external-game"> 游戏</i></div><ul></ul><a href="/2048" title="2048小游戏" target="_blank">2048小游戏</a><ul></ul><a href="/tantanqiu" title="变色弹球跳台阶小游戏" target="_blank">变色弹球跳台阶小游戏</a></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//yfshare.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">Jack Wang Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=2.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=2.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=2.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?3890bdc1bfaccae9364479b65f36fbd2";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=2.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=2.0.0"></script></div></body></html>